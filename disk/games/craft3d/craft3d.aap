import essentials
from expansions import Accelerator
import math
import random

acc = Accelerator()

chunk_data = {}
terrain = 'disk/games/craft3d/textures/terrain.aai'

blocks = { # face texture, if solid (cull neighbors), and model.
    "grass_block": ((1, 1, 2, 0, 1, 1), True, "cube"),
    "dirt": ((2, 2, 2, 2, 2, 2), True, "cube"),
    "stone": ((3, 3, 3, 3, 3, 3), True, "cube"),
    "bedrock": ((4, 4, 4, 4, 4, 4), True, "cube"),
    "leaves": ((5, 5, 5, 5, 5, 5), True, "cube"),
    "grass": ((6, 6), False, "cross"), #Cross model, so 2 textures
    "log": ((7, 7, 8, 8, 7, 7), True, "cube"),
    "planks": ((9, 9, 9, 9, 9, 9), True, "cube"),
    "cobblestone": ((10, 10, 10, 10, 10, 10), True, "cube"),
    "flower": ((11, 11), False, "cross"),
    "coal_ore": ((12, 12, 12, 12, 12, 12), True, "cube"),
    "iron_ore": ((13, 13, 13, 13, 13, 13), True, "cube"),
    "water": (14, False, "liquid")
}

def crop_from_idx(idx, atlasize=64, tilesize=16):
    tiles_per_row = atlasize // tilesize
    tx = idx % tiles_per_row
    ty = idx // tiles_per_row
    x = tx * tilesize
    y = ty * tilesize
    return [x, y, x + tilesize, y + tilesize]

def cube(x, y, z, visableFaces, block_id, model="cube"):
    texture = blocks[block_id][0]
    if model == "cube":
        if visableFaces[0]:
            acc.draw_quad((x, y, z + 0.5), (0, 0, 0), (1, 1), 15, (0, 0, 0), True, (terrain, 0, crop_from_idx(texture[0])))  # Front
        if visableFaces[1]:
            acc.draw_quad((x, y, z - 0.5), (0, 180, 0), (1, 1), 15, (0, 0, 0), True, (terrain, 0, crop_from_idx(texture[1])))  # Back
        if visableFaces[2]:
            acc.draw_quad((x, y + 0.5, z), (-90, 0, 0), (1, 1), 15, (0, 0, 0), True, (terrain, 0, crop_from_idx(texture[2])))  # Bottom
        if visableFaces[3]:
            acc.draw_quad((x, y - 0.5, z), (90, 0, 0), (1, 1), 15, (0, 0, 0), True, (terrain, 0, crop_from_idx(texture[3])))  # Top
        if visableFaces[4]:
            acc.draw_quad((x + 0.5, y, z), (0, 90, 0), (1, 1), 15, (0, 0, 0), True, (terrain, 0, crop_from_idx(texture[4])))  # Right
        if visableFaces[5]:
            acc.draw_quad((x - 0.5, y, z), (0, -90, 0), (1, 1), 15, (0, 0, 0), True, (terrain, 0, crop_from_idx(texture[5])))  # Left
    elif model == "cross":
        tex = blocks[block_id][0][0]
        acc.draw_quad((x, y, z), (0, 45, 0), (1, 1), 15, (0, 0, 0), False, (terrain, 0, crop_from_idx(tex)))
        acc.draw_quad((x, y, z), (0, -45, 0), (1, 1), 15, (0, 0, 0), False, (terrain, 0, crop_from_idx(tex)))
    elif model == "liquid":
        tex = blocks[block_id][0]
        acc.draw_quad((x, y - 0.375, z), (90, 0, 0), (1, 1), 15, (0, 0, 0), True, (terrain, 0, crop_from_idx(tex)))

world_data = {}

def add_tree(x, y, z):
    structure = []
    for i in range(4):
        structure.append((0, -i, 0, "log"))
    for dx in range(-2, 3):
        for dy in range(3, 6):
            for dz in range(-2, 3):
                if abs(dx) + abs(dz) < 4 and not (dx == 0 and dz == 0 and dy == 3):
                    structure.append((dx, -dy, dz, "leaves"))
    return structure

def chunk(x, z):
    for i in range(8):
        for j in range(8):
            for k in range(16):
                if k == 0:
                    block_type = "grass_block"
                elif k < 4:
                    block_type = "dirt"
                elif k < 15:
                    block_type = "stone"
                else:
                    block_type = "bedrock"
                world_data[(x + i, k, z + j)] = block_type

            # chance of tree on surface
            if random.random() < 0.01:
                for (dx, dy, dz, block_type) in add_tree(x + i, 0, z + j):
                    world_data[(x + i + dx, dy - 1, z + j + dz)] = block_type

            # chance of grass on surface
            if random.random() < 0.05 and block_type != "log": #stop ignoring me bruh
                if random.random() < 0.2:
                    world_data[(x + i, -1, z + j)] = "flower"
                else:
                    world_data[(x + i, -1, z + j)] = "grass"


def build_world(size=2):
    global world_data
    world_data = {}
    for i in range(-size, size):
        for j in range(-size, size):
            chunk(i * 8, j * 8)

def draw_world():
    for (cx, cy, cz), block_id in world_data.items():
        # Skip unknown blocks
        if block_id not in blocks:
            continue

        neighbors = [
            (cx, cy, cz + 1),  # front
            (cx, cy, cz - 1),  # back
            (cx, cy + 1, cz),  # bottom
            (cx, cy - 1, cz),  # top
            (cx + 1, cy, cz),  # right
            (cx - 1, cy, cz),  # left
        ]

        visableFaces = []
        for npos in neighbors:
            if npos not in world_data:
                visableFaces.append(True)   # no neighbor at all = visible
            else:
                n_block = world_data[npos]
                if n_block not in blocks:
                    visableFaces.append(True)
                else:
                    is_solid = blocks[n_block][1]
                    visableFaces.append(not is_solid)  # visible only if neighbor is non-solid

        model = blocks[block_id][2]
        cube(cx, cy, cz, visableFaces, block_id, model=model)


def main():
    acc.camX = 0
    acc.camY = 0 #vertical direction
    acc.camZ = 0

    acc.pitch = 0
    acc.yaw = 0
    movespeed = 0.5
    sensitivity = 100

    pos = [0.0, -5.0, 0.0]   # starting player position
    movespeed = 0.2

    skycolor = 21

    debug = False

    build_world()
    running = True
    #timeOfDay = 0
    while running:
        screen.clear(skycolor)
        draw_world()
        # acc.draw_quad((acc.camX, acc.camY, acc.camZ), (timeOfDay, 0, 0), (32, 32), 22, (0, 0, -100), True) #no no, of course this doesn't work, because why would it?
        acc.flush()
        screen.draw_line((128, 96-4), (128, 96+4), 23)
        screen.draw_line((128+4, 96), (128-4, 96), 23)
        if debug:
            screen.draw_string(0, 0, [round(x, 2) if isinstance(x, float) else x for x in pos], 0, 23)
        screen.update(False, False)
        #timeOfDay = (timeOfDay + 1) % 360

        if 10 >= pos[1] >= 5:
            skycolor = 9
        elif 16 >= pos[1] >= 10:
            skycolor = 2
        else: 
            skycolor = 21

        keys = obtain_keys_held()
        relMouse = screen.getRelMouse()

        # Update camera position based on yaw and pitch
        if keys[keycode_w]:
            pos[0] -= math.sin(math.radians(acc.yaw)) * movespeed
            pos[2] += math.cos(math.radians(acc.yaw)) * movespeed
        if keys[keycode_s]:
            pos[0] += math.sin(math.radians(acc.yaw)) * movespeed
            pos[2] -= math.cos(math.radians(acc.yaw)) * movespeed
        if keys[keycode_a]:
            pos[0] -= math.sin(math.radians(acc.yaw + 90)) * movespeed
            pos[2] += math.cos(math.radians(acc.yaw + 90)) * movespeed
        if keys[keycode_d]:
            pos[0] -= math.sin(math.radians(acc.yaw - 90)) * movespeed
            pos[2] += math.cos(math.radians(acc.yaw - 90)) * movespeed


        if keys[keycode_SPACE]:
            pos[1] -= movespeed
        if keys[keycode_LSHIFT]:
            pos[1] += movespeed

        acc.camX, acc.camY, acc.camZ = pos

        if relMouse != (0, 0):
            acc.yaw -= relMouse[0] * 0.1 * (sensitivity//100)
            acc.pitch += relMouse[1] * 0.1 * (sensitivity//100)
            acc.pitch = max(-89, acc.pitch)  # Prevent flipping
            acc.pitch = min(89, acc.pitch)  # Prevent flipping
        for get_events:
            if key_down_event:
                if key_r:
                    pos = [0, -5, 0]
                    vel = [0, 0, 0]
                    acc.pitch = 0
                    acc.yaw = 0
                    build_world()
                if key_v:
                    debug = not debug
            if quit_event:
                running = False

main()