import essentials
import time
import copy
import os

# Constants
PALETTE_COLS = 8
PALETTE_ROWS = 3
PALETTE_SIZE = 24
PALETTE_CELL = 12
TOOL_PEN = 0
TOOL_ERASER = 1
TOOL_FILL = 2
TOOLS = ["Pen", "Eraser", "Fill"]
BASE25 = "0123456789ABCDEFGHIJKLMNO"  # O = transparent (-1)

# Canvas modes
canvas_modes = {
    "normal": {"w": 192, "h": 128},
    "compact": {"w": 64, "h": 64}
}
active_mode = "normal"

# Canvas area
CANVAS_X = 8
CANVAS_Y = 48
CANVAS_W = canvas_modes[active_mode]["w"]
CANVAS_H = canvas_modes[active_mode]["h"]
canvas_buffers = {
    "normal": [[0 for _ in range(192)] for _ in range(128)],
    "compact": [[0 for _ in range(64)] for _ in range(64)]
}
canvas = canvas_buffers[active_mode]

def rle_encode(flat):
    result = ""
    i = 0
    while i < len(flat):
        color = flat[i]
        run = 1
        while run < 24 and i + run < len(flat) and flat[i + run] == color:
            run += 1
        char_color = BASE25[24] if color == -1 else BASE25[color]
        char_run = BASE25[run]
        result += char_color + char_run
        i += run
    return result

def rle_decode(rle):
    flat = []
    i = 0
    while i + 1 < len(rle):
        try:
            raw = BASE25.index(rle[i])
            color = -1 if raw == 24 else raw
            run = BASE25.index(rle[i + 1])
            flat.extend([color] * run)
            i += 2
        except ValueError:
            # Skip invalid character and move on
            i += 1
    return flat

def draw_palette(selected_color):
    for i in range(PALETTE_SIZE):
        x = 8 + (i % PALETTE_COLS) * PALETTE_CELL
        y = 8 + (i // PALETTE_COLS) * PALETTE_CELL
        screen.draw_rect((x, y), (x + PALETTE_CELL, y + PALETTE_CELL), i)
        if i == selected_color:
            screen.draw_rect((x, y), (x + PALETTE_CELL, y + PALETTE_CELL), i, 23)

def draw_tools(selected_tool):
    for i, name in enumerate(TOOLS):
        x = 120
        y = 8 + i * 8
        color = 23 if i == selected_tool else 7
        screen.draw_string(x, y - 4, name, 0, color)

def draw_buttons():
    screen.draw_string(200, 8, "{save}", 0, 23)
    screen.draw_string(200, 20, "{folder}", 0, 23)
    screen.draw_string(200, 30, "{cross_box}", 0, 23)

def draw_canvas():
    screen.draw_rect((CANVAS_X - 1, CANVAS_Y - 1), (CANVAS_X + CANVAS_W + 1, CANVAS_Y + CANVAS_H + 1), 7)
    for y in range(CANVAS_H):
        for x in range(CANVAS_W):
            screen.draw_pixel((CANVAS_X + x, CANVAS_Y + y), canvas[y][x])

def get_palette_at(mx, my):
    for i in range(PALETTE_SIZE):
        x = 8 + (i % PALETTE_COLS) * PALETTE_CELL
        y = 8 + (i // PALETTE_COLS) * PALETTE_CELL
        if x <= mx < x + PALETTE_CELL and y <= my < y + PALETTE_CELL:
            return i
    return None

def get_tool_at(mx, my):
    for i in range(len(TOOLS)):
        x = 120
        y = i * 8
        if x <= mx < x + 48 and y <= my < y + 12:
            return i
    return None

def get_button_at(mx, my):
    if 200 <= mx < 240 and 8 <= my < 16:
        return "save"
    if 200 <= mx < 240 and 20 <= my < 28:
        return "load"
    if 200 <= mx < 240 and 24 <= my < 40:
        return "toggle"
    return None

def in_canvas(mx, my):
    return CANVAS_X <= mx < CANVAS_X + CANVAS_W and CANVAS_Y <= my < CANVAS_Y + CANVAS_H

def save_canvas():
    # Convert canvas to flat array
    flat = [pix for row in canvas for pix in row]
    # Encode the data
    data = rle_encode(flat)
    
    # Save with metadata format using underscores
    with open(f"disk/saved_{active_mode}.aai", "w") as f:
        f.write(f"aai_{CANVAS_W}x{CANVAS_H}_{data}")
    
    # Success feedback
    audio.beep("G4", 0.1)
    audio.rest(0.2)
    audio.beep("B4", 0.1)
    audio.rest(0.2)

def load_canvas(initial=False):
    global canvas, CANVAS_W, CANVAS_H
    if not os.path.exists(f"disk/saved_{active_mode}.aai"):
        save_canvas()
    try:
        with open(f"disk/saved_{active_mode}.aai", "r") as f:
            content = f.read().strip()
            parts = content.split('_')
            
            # Validate file format
            if len(parts) != 3 or parts[0] != "aai":
                raise ValueError(f"Invalid AAI file format. # of underscores detected: {len(parts)}, header (first part): {parts[0]}")
            
            # Parse dimensions
            dim = parts[1].split('x')
            if len(dim) == 2:
                w = int(dim[0])
                h = int(dim[1])
                if w != CANVAS_W or h != CANVAS_H:
                    print("Warning: Image dimensions don't match canvas size")
            
            # Get the data and decode
            rle = parts[2]
            flat = rle_decode(rle)
            
            # Initialize canvas
            canvas = [[0 for _ in range(CANVAS_W)] for _ in range(CANVAS_H)]
            
            # Fill canvas with data
            i = 0
            for y in range(CANVAS_H):
                for x in range(CANVAS_W):
                    if i < len(flat):
                        canvas[y][x] = flat[i]
                    i += 1
                    
        canvas_buffers[active_mode] = canvas
        if not initial:
            audio.beep("F4", 0.1)
            audio.rest(0.2)
            audio.beep("F4", 0.1)
            audio.rest(0.2)
        screen.clear()
    except Exception as e:
        print(f"Load failed: {e}")
        audio.play_wave("C1", 0x12, "C4", 31, 0.5)

def toggle_canvas():
    global active_mode, canvas, CANVAS_W, CANVAS_H
    active_mode = "compact" if active_mode == "normal" else "normal"
    CANVAS_W = canvas_modes[active_mode]["w"]
    CANVAS_H = canvas_modes[active_mode]["h"]
    canvas = canvas_buffers[active_mode]
    screen.clear()

# Load default canvas
load_canvas(True)
screen.clear()
screen.update()

def flood_fill(x, y, target_color, replacement_color):
    if target_color == replacement_color or not (0 <= x < CANVAS_W and 0 <= y < CANVAS_H):
        return
    stack = [(x, y)]
    while stack:
        cx, cy = stack.pop()
        if 0 <= cx < CANVAS_W and 0 <= cy < CANVAS_H and canvas[cy][cx] == target_color:
            canvas[cy][cx] = replacement_color
            stack.extend([
                (cx + 1, cy), (cx - 1, cy),
                (cx, cy + 1), (cx, cy - 1)
            ])

undo_stack = []

def push_undo():
    undo_stack.append(copy.deepcopy(canvas))

def undo():
    global canvas
    if undo_stack:
        canvas[:] = undo_stack.pop()
        screen.clear()
        screen.update()

def main():
    running = True
    color = 23
    tool = TOOL_PEN
    prev_x = None
    prev_y = None

    while running:
        mouse_x, mouse_y = screen.getMousePos()
        screen.clear()
        draw_palette(color)
        draw_tools(tool)
        draw_buttons()
        draw_canvas()
        screen.update()

        for get_events:
            if quit_event:
                running = False
            elif key_down_event:
                if key_i:
                    toggle_canvas()
                    continue
                elif key_c:
                    for y in range(CANVAS_H):
                        for x in range(CANVAS_W):
                            canvas[y][x] = 0
                    screen.clear()
                    screen.update()
                elif key_z and init_mods & keymod_CTRL:  # Ctrl+Z for undo
                    undo()
                    continue

            elif mouse_held_0:
                sel = get_palette_at(mouse_x, mouse_y)
                if sel is not None:
                    color = sel
                    continue
                tsel = get_tool_at(mouse_x, mouse_y)
                if tsel is not None:
                    tool = tsel
                    continue
                bsel = get_button_at(mouse_x, mouse_y)
                if bsel == "save":
                    save_canvas()
                    continue
                elif bsel == "load":
                    load_canvas()
                    continue
                elif bsel == "toggle":
                    toggle_canvas()
                    continue

                if in_canvas(mouse_x, mouse_y):
                    # --- PUSH UNDO BEFORE CHANGING CANVAS ---
                    push_undo()
                    cx = mouse_x - CANVAS_X
                    cy = mouse_y - CANVAS_Y
                    if tool == TOOL_PEN:
                        if prev_x is not None and prev_y is not None:
                            dx = mouse_x - prev_x
                            dy = mouse_y - prev_y
                            steps = max(abs(dx), abs(dy))
                            if steps > 0:
                                for i in range(steps + 1):
                                    ix = int(prev_x + dx * i / steps) - CANVAS_X
                                    iy = int(prev_y + dy * i / steps) - CANVAS_Y
                                    if 0 <= ix < CANVAS_W and 0 <= iy < CANVAS_H:
                                        canvas[iy][ix] = color
                            else:
                                if 0 <= cx < CANVAS_W and 0 <= cy < CANVAS_H:
                                    canvas[cy][cx] = color
                        else:
                            if 0 <= cx < CANVAS_W and 0 <= cy < CANVAS_H:
                                canvas[cy][cx] = color
                    elif tool == TOOL_ERASER:
                        for oy in range(-6, 7):
                            for ox in range(-6, 7):
                                ex = cx + ox
                                ey = cy + oy
                                if 0 <= ex < CANVAS_W and 0 <= ey < CANVAS_H:
                                    canvas[ey][ex] = 0
                    elif tool == TOOL_FILL:  # Now fill tool
                        if 0 <= cx < CANVAS_W and 0 <= cy < CANVAS_H:
                            target_color = canvas[cy][cx]
                            flood_fill(cx, cy, target_color, color)
                    prev_x = mouse_x
                    prev_y = mouse_y
                else:
                    prev_x = None
                    prev_y = None
            else:
                prev_x = None
                prev_y = None

main()
