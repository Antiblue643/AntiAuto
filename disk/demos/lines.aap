import essentials
import random
import math
import time

#uses lines to draw the noise pattern.

points = []
NUM_POINTS = 16

def init_points():
    global points
    points = []
    for _ in range(NUM_POINTS):
        x = random.randint(0, 256)
        y = random.randint(0, 192)
        dx = random.uniform(-1, 1)
        dy = random.uniform(-1, 1)
        points.append([x, y, dx, dy, 1.0])  # Added speed multiplier

def update_points():
    mx, my = screen.getMousePos()
    for point in points:
        # Update position based on velocity and speed multiplier
        point[0] += point[2] * point[4]
        point[1] += point[3] * point[4]
        
        # Drag points towards mouse position
        dist = math.sqrt((mx - point[0])**2 + (my - point[1])**2)
        if dist < 100:
            point[2] += (mx - point[0]) / 200
            point[3] += (my - point[1]) / 200

        # Slow down points over time, cap at 0.006
        point[4] *= 0.99
        point[4] = max(point[4], 0.006)

        # Bounce off edges
        if point[0] < 0 or point[0] > 256:
            point[2] *= -1
        if point[1] < 0 or point[1] > 192:
            point[3] *= -1

def render():
    # Draw connections between points
    for i, p1 in enumerate(points):
        for j, p2 in enumerate(points[i+1:], i+1):
            # Calculate midpoint
            mx = (p1[0] + p2[0]) / 2
            my = (p1[1] + p2[1]) / 2
            
            # Draw line between points if they're close enough
            dist = math.sqrt((p2[0] - p1[0])**2 + (p2[1] - p1[1])**2)
            if dist < 64:  # Only draw lines between nearby points
                screen.draw_line(int(p1[0]), int(p1[1]), int(mx), int(my), 23 if dist < 32 else 13)
                screen.draw_line(int(mx), int(my), int(p2[0]), int(p2[1]), 23 if dist < 32 else 13)
        
        # Draw the point itself
        screen.draw_ellipse(int(p1[0]), int(p1[1]), 2, 2, 23)

def main():
    init_points()
    running = True
    while running:
        screen.clear()
        update_points()
        render()
        screen.update()
        
        for get_events:
            if quit_event:
                running = False
            elif key_down_event:
                if key_SPACE:
                    init_points()  # Reset points when space is pressed

main()